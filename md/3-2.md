# 3.2 사용자 정의 쿠키(Cookie)

- HttpSession을 이용할 때는 JSESSIONID와 같은 쿠키를 이용하지만 이는 개발자가 직접 정의하는 일반적인 쿠키
와는 다르기 때문에 세션쿠키(session cookie)라는 별개의 이름으로 구분한다.
- 일반적으로 쿠키(Cookie)라고 하면 `개발자의 필요`에 의해서 생성되어 브라우저에 전송하는 `사용자 정의 쿠키를`를
일컫는 경우가 많다.


## `쿠키의 생성/전송`
- 사용자가 정의하는 쿠키와 서버에서 자동으로 발행되는 쿠키(JSESSIONID)의 차이점

|             |                         사용자 정의 쿠키                         | WAS에서 발행하는 쿠키<br>(세션 쿠키) |
|:-----------:|:---------------------------------------------------------:|:------------------------:|
|     생성      |           개발자가 직접 newCookie()로 생성<br/>경로도 지정 가능           |            자동            |
|     전송      |       반드시 HttpServletResponse에 addCookie()를 통해야만 전송       |                          |
|    유효기간     |                  쿠키 생성할 때 초 단위로 지정할 수 있음                  |           지정불가           |
| 브라우저의 보관 방식 | 유효기간이 없는 경우에는 메모리상에만 보관<br/>유효기간이 있는 경우에는 파일이나 기타 방식으로 보관 |        메모리상에만 보관         |
|   쿠키의 크기    |                            4b                             |            4b            |
> 개발자가 직접 쿠키를 생성하는 경우 newCookie()를 이용해서 생성하며 이떄 문자열로된 name과 value가 필요하다.<br>
> 이때, value는 일반적인 문자열로 저장이 불가능하기 때문에 URLEncoding된 문자열로 저장해야한다.(한글저장 불가)

### 쿠키를 사용하는 경우
- 쿠키는 서버와 브라우저 사이를 오가기 떄문에 보안에 취약하기 떄문에 용도는 상당히 제한적임
- 따라서 오랜 시간 보관해야 하는 데이터는 항상 서버에 보관하고 약간의 편의를 제공하기 위한 데이터는 쿠키로 보관
하는 방식을 사용
- 예를 들어 '오늘 하루 이 창 열지 않기' or '최근 본 상품 목록'과 같이 조금은 사소하고 서버에서 보관할 필요가 없는
데이터 들은 쿠키를 이용해서 처리한다.
> 쿠키의 용도는 상당히 제한적이지만 모바일에서 시작된 `자동 로그인`덕분에 쿠키의 위상이 변하게 되었다. 쿠키의 유효기간
을 지정하는 경우 브라우저가 종료되더라도 보관되기 때문에 이러한 동작을 이용하여 모바일에서는 매번 사용자가 로그인하는 수고로움
을 덜어줄 수 있다.

### 쿠키와 세션
- 쿠키와 세션은 웹 개발에서 클라이언트와 서버 간의 상태(state)정보를 유지하기 위해 사용되는
두 가지 다른 기술이다. 이 둘은 상태가 없는(HTTP Stateless)특성을 가진 웹에서 상태
정보를 관리하는 방법을 제공하며 다음과 같은 차이점이 있다.
- 쿠키 : `쿠키는 클라이언트(브라우저)에 저장되는` 작은 텍스트 파일이며 서버에서 생성하여
클라이언트에 전달하고, 클라이언트는 이후 서버로의 모든 요청에 이 쿠키를 포함시켜 전송한다.
- 세션 : `세션은 서버 측에 저장되는 데이터로` 서버는 각 클라이언트를 식별하기 위한 유니크한
세션 ID를 생성하여 쿠키 형태로 클라이언트에 전달한다.

> 정리하자면 세션 쿠키와 사용자 정의 쿠키는 처음 서버에서 클라이언트로 전송될 때는 Response
> Header에 'Set-Cookie' 항목을 사용하여 쿠키를 설정하고 클라이언트는 이 쿠키들을 저장하고
> 이후 서버로 요청을 보낼 때마다 HTTP 요청 헤더의 'Cookie'항목에 저장된 쿠키들을 포함하여 전송한다.

- 예시 - HTTP Response
```mathematica
HTTP/1.1 200 OK
Set-Cookie: JSESSIONID=12345; Path=/; HttpOnly
Set-Cookie: userPref=darkMode; Expires=Wed, 09 Jun 2021 10:18:14 GMT
```

- 예시 - HTTP Request
```mathematica
GET /index.html HTTP/1.1
Host: www.example.com
Cookie: JSESSIONID=12345; userPref=darkMode
```

> 쿠키의 'Path' 속성은 해당 쿠키가 전송되어야 하는 서버상의 경로를 지정한다.<br>
> 예를 들어, 쿠키에 'Path=/blog'가 설정되어 있다면 해당 쿠키는 클라이언트가 
> 'www.example.com/blog' 경로 또는 그 하위 경로 'www.example.com/blog/article-1'
> 등에 대한 요청을 할 때만 서버로 전송된다. <br> 반면, 'www.example.com/gallery'와 같은 
> 'blog' 경로와는 다른 요청에는 이 쿠키는 포함되어 전송되지 않는다.

### 실습 - 조회한 Todo확인하기

#### Todo 목록에서 조회했던 Todo 번호(tno)들을 쿠키를 이용해서 보관해 보도록 하기. 이 작업은 다음과 같은 방식으로 동작한다.
1. 브라우저에서 전송된 쿠키가 있는지 확인
   - 있다면 해당 쿠키의 value를 활용한다.
   - 없다면 새로운 문자열으 생성한다.
2. 쿠키의 이름은 'viewTodos'로 지정
3. 문자열 내에 현재 Todo의 번호(tno)가 있는지 확인
   - 없다면 원래 viewTodos의 value에 해당 tno+"-" 값을 덧붙인다.
4. "2-3-4-"와 같은 형태로 연결하고 이미 조회한 번호는 추가하지 않음
5. 쿠키의 유효기간은 24시간으로 지정하고 쿠키를 담아서 Response를 전송

#### TodoReadController에 추가되어야할 Code
1. 현재 Request에 있는 모든 쿠키 중에 조회 목록 쿠키(viewTodos)를 찾아내는 Method - findCookie()
2. 특정한 tno가 쿠키의 내용물이 있는지 확인하는 Code

#### TodoReadController Code
```java
@Log4j2
@WebServlet(name = "TodoReadController", urlPatterns = "/todo/read")
public class TodoReadController extends HttpServlet {
  TodoService todoService = TodoService.INSTANCE;
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    try{
      Long tno = Long.parseLong(req.getParameter("tno"));

      TodoDTO todoDTO = todoService.get(tno);
      //모델 담기
      req.setAttribute("dto",todoDTO);

      //쿠키 찾기
      Cookie viewTodoCookie = findCookie(req.getCookies(), "viewTodos");
      String todoListStr = viewTodoCookie.getValue();
      boolean exist = false;

      //해당 tno가 todoListStr에 존재하는지 check
      if(todoListStr != null && todoListStr.indexOf(tno+"-") >= 0)
        //indexOf는 해당문자열이 몇번째 인덱스에서 시작되는지 return한다. 없으면 -1 return
        exist = true;

      log.info("exist: " + exist);

      //해당 tno가 존재하지 않는다면 기존의 문자열에 더해서 새로운 쿠키를 생성하여 담아준다.
      if(!exist){
        todoListStr += tno+"-";
        viewTodoCookie.setValue(todoListStr);
        viewTodoCookie.setMaxAge(60*60*24);
        viewTodoCookie.setPath("/");
        resp.addCookie(viewTodoCookie);
      }

      req.getRequestDispatcher("/WEB-INF/todo/read.jsp").forward(req,resp);
    }catch (Exception e){
      log.error(e.getMessage());
      throw new ServletException("read error");
    }
  }

  private Cookie findCookie(Cookie[] cookies, String cookieName){
    Cookie targetCookie = null;

    //Request에 쿠키가 있다면 해당 쿠키 찾기
    if(cookies != null && cookies.length > 0){
      for(Cookie ck : cookies){
        if(ck.getName().equals(cookieName)){
          targetCookie = ck;
          break;
        }
      }
    }
    //Request에 쿠키가 없다면 생성, 이떄 유효 기간은 24시간으로 설정
    if(targetCookie == null){
      targetCookie = new Cookie(cookieName,"");
      targetCookie.setPath("/");
      targetCookie.setMaxAge(60*60*24); // 초단위 이므로 24시간으로 설정
    }
    return targetCookie;
  }

}
```

- doGet()에서 변경된 부분은 'viewTodos' 이름의 쿠키를 찾고(findCookie()),
쿠키의 내용물을 검사한 후에 만일 조회한 적이 없는 번호라면 쿠키의 내용물을 갱신해 브라우저로
보내 주는 것
- 쿠키를 변경할 때에는 다시 경로나 유효시간을 세팅해야 하는 점을 주의할 것
- 앞의 코드를 적용하면 조회했던 번호들은 다음과 같은 쿠키 형태로 보관되고, 24시간 동안 유지
- 실행 후 해당 Todo를 읽으면 브라우저의 쿠키 저장소에 'viewTodos'이름으로 해당 tno+'-'이
저장된 것을 볼 수 있다.

> 이렇게 만든 하루동안 조회했던 목록을 이용해서 '조회수'를 처리하거나 '최근 본 상품 목록'
> 을 처리할 수 있다.


## `쿠키와 세션을 같이 활용하기`
- 작성된 코드를 실행하면 '/todo/..'로 시작하는 모든 경로에 대해서 로그인이 필요하기 때문에 매번 로그인을 해야하는 불편함이 있다.
- 이런 경우 쿠키를 이용한 '자동 로그인'으로 해결할 수 있다. 
- '자동 로그인'은 'remember-me'라는 이름으로 부르기도 하며 로그인한 사용자의 정보를 쿠키에 보관하고 이를 이용해서 사용자의
정보를 HttpSession에 담는 방식이다.
- 사실 자동 로그인 처리를 제대로 작성하려면 생각보다 많은 것을 고려해야 하는데 이는 뒤쪽에서 스프링 부트와 시큐리티에서 다시 다룰 것이고
이 예제에서는 간단히 아이디어를 검증하는 수준으로 구현할 것

### 자동 로그인 준비
- 자동 로그인을 위해서
  1. 쿠키에 어떤 값을 보관할 것인지 결정해야 함
  2. 이 값의 유효시간도 고려해야 함
- 로그인은 다음과 같은 방식으로 구현
  1. 사용자가 로그인할 때 임의의 문자열 생성, 이를 DB에 보관
  2. 쿠키에는 생성된 문자열을 value로 설정, 유효기간은 1주일로 지정
- 로그인 체크는 다음과 같은 방식으로 구현
  1. 현재 사용자의 HttpSession에 로그인 정보(loginInfo)가 없는 경우에만 쿠키를 확인
  2. 쿠키의 값과 DB의 값을 비교하고 같다면 사용자의 정보를 읽어와서 HttpSession에 사용자 정보를 추가

> 이러한 방식으로 구현할 경우 현실적으로 쿠키의 값을 탈취당하면 문제가 발생하기 때문에 좀더 안전하게 하기 위해서는 주기적으로
> 쿠키의 값을 갱신하는 부분이 추가되어야만 한다. <br>
> 우선은 UUID를 이용한 임의의 문자열을 이용하도록 한다. <br>
> UUID(universally unique identifier)는 범용 고유 식별자로 고유한 번호를 랜덤으로 생성할 때 많이 사용하며 자바
> 에서는 java.util 패키지를 이용해서 이를 처리한다.

- 구현을 위해 tbl_member 테이블에 임의의 문자열을 보관하기 위한 uuid라는 이름의 칼럼을 추가한다.
```sql
alter table tbl_member add column uuid varchar(50);
```

### 실습 - 자동 로그인 처리

1. login.jsp에 자동 로그인 여부를 묻는 체크박스를 추가
  ```html
  <body>
  
  <c:if test="${param.result == 'error'}">
    <h1>로그인 에러</h1>
  </c:if>
  
  <form action="/login" method="post">
    <input type="text" name="mid">
    <input type="text" name="mpw">
    <label>
      <input type="checkbox" name="auto">
      자동 로그인
    </label>
    <button type="submit">LOGIN</button>
  </form>
  </body>
  ```

2. 로그인을 처리하는 LoginController의 doPost()에서는 'auto'라는 이름으로 체크박스에서 전송되는 값이 'on'인지 확인
  ```java
  String auto = req.getParameter("auto");
  boolean rememberMe = auto != null && auto.equals("on");
  ```

3. MemberVo, MemberDTO의 수정
  ```java
  public class MemberVO {
    private String mid;
    private String mpw;
    private String mname;
    private String uuid;
  }
  ```
  ```java
  public class MemberDTO {
    private String mid;
    private String mpw;
    private String mname;
    private String uuid;
  }
  ```

4. MemberDAO 추가적인 기능 작성 - rememberMe가 true라면 tbl_member 테이블에 사용자의 정보에 uuid를 수정하는 기능
  ```java
  public void updateUuid(String mid, String uuid) throws Exception{
      String query = "update tbl_member set uuid = ? where mid = ?";
  
      @Cleanup Connection connection = ConnectionUtil.INSTANCE.getConnection();
      @Cleanup PreparedStatement preparedStatement = connection.prepareStatement(query);
  
      preparedStatement.setString(1,uuid);
      preparedStatement.setString(2,mid);
      preparedStatement.executeUpdate();
    }
  ```

5. MemberService 메소드 추가 - DAO호출 메소드 작성
  ```java
  public void updateUuid(String mid, String uuid)throws Exception{
      dao.updateUuid(mid,uuid);
    }
  ```

6. LoginController의 doPost() 로직 추가 - rememberMe가 true이면 uuid를 생성하고 MemberService 호출
  ```java
  @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
      log.info("login post...................");
  
      String mid = req.getParameter("mid");
      String mpw = req.getParameter("mpw");
  
      //자동 로그인 처리
      String auto = req.getParameter("auto");
      boolean rememberMe = auto != null && auto.equals("on");
  
      try{
        MemberDTO memberDTO = MemberService.INSTANCE.login(mid,mpw);
  
        if (rememberMe){
          String uuid = UUID.randomUUID().toString();
  
          MemberService.INSTANCE.updateUuid(mid,uuid);
          memberDTO.setUuid(uuid);
        }
  
        HttpSession session = req.getSession();
        session.setAttribute("loginInfo",memberDTO);
        resp.sendRedirect("/todo/list");
      } catch (Exception e){
        resp.sendRedirect("/login?result=error");
      }
    }
  ```

> 여기까지 완료 시 자동로그인 여부에 체크를 선택하고 로그인하면 tbl_member 테이블에 uuid가 수정(혹은 추가)되는 것을
> 볼 수 있다.

7. LoginController의 doPost() - 쿠키 생성 및 전송
  ```java
  if (rememberMe){
          //uuid 생성
          String uuid = UUID.randomUUID().toString();
          //DB에 해당 member의 uuid를 update
          MemberService.INSTANCE.updateUuid(mid,uuid);
          //DTO에도 추가
          memberDTO.setUuid(uuid);
          //쿠키 생성 및 전송
          Cookie rememberCookie = new Cookie("remember-me", uuid);
          rememberCookie.setMaxAge(60*60*24*7);   //쿠키의 유효기간은 1주일
          rememberCookie.setPath("/");
          resp.addCookie(rememberCookie);
        }
  ```

> 이제 자동 로그인 체크 후 로그인 시, 브라우저의 쿠키에는 remember-me라는 이름의 쿠키가 생성되어 있어야 한다.

8. 쿠키의 값을 이용한 사용자 조회 - MemberDAO의 selectUUID() 기능, MemberService의 getByUUID() 기능

  ```java
  public MemberVO selectUUID(String uuid) throws Exception{
      String query = "select mid, mpw, mname, uuid from tbl_member where uuid = ?";
  
      @Cleanup Connection connection = ConnectionUtil.INSTANCE.getConnection();
      @Cleanup PreparedStatement preparedStatement = connection.prepareStatement(query);
      preparedStatement.setString(1,uuid);
  
      @Cleanup ResultSet resultSet = preparedStatement.executeQuery();
  
      resultSet.next();
  
      MemberVO memberVO = MemberVO.builder()
              .mid(resultSet.getString(1))
              .mpw(resultSet.getString(2))
              .mname(resultSet.getString(3))
              .uuid(resultSet.getString(4))
              .build();
  
      return memberVO;
    }
  ```
  
  ```java
  public MemberDTO getByUUID(String uuid) throws Exception {
      MemberVO vo = dao.selectUUID(uuid);
      MemberDTO memberDTO = modelMapper.map(vo,MemberDTO.class);
      
      return memberDTO;
    }
  ```

9. LoginCheckFilter에서의 쿠키 체크

- 과거에 LoginCheckFilter는 HttpSession에 'loginInfo'라는 이름으로 객체가 저장된 것인지만 확인했다.
- 하지만 이제는 HttpSession에는 없고, 쿠키에 UUID 값만 있는 경우를 고려해야 한다.
- 전체 진행 과정
  1. HttpServletRequest를 이용해서 모든 쿠키 중에서 'remember-me' 이름의 쿠키를 검색
  2. 해당 쿠키의 value를 이용해서 MemberService를 통해 MemberDTO를 구성
  3. HttpSession을 이용해서 'loginInfo'라는 이름으로 MemberDTO를 setAttribute()
  4. 정상적으로 FilterChain의 doFilter()를 수행

  ```java
  @WebFilter(urlPatterns = {"/todo/*"})
  @Log4j2
  public class LoginCheckFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
      log.info("Login check filter.........");
  
      HttpServletRequest req = (HttpServletRequest)request;
      HttpServletResponse resp = (HttpServletResponse)response;
  
      //존재하는 경우 해당 세션 객체 반환, 그렇지 않은 경우 새로운 세션 객체 생성 후 반환
      HttpSession session = req.getSession();
  
      if(session.getAttribute("loginInfo") != null){
        chain.doFilter(request, response);
        return;
      }
  
      //session에 loginInfo 값이 없다면
      //쿠키를 체크
      Cookie cookie = findCookie(req.getCookies(),"remember-me");
  
      //세션에도 없고 쿠키도 없다면 그냥 로그인으로
      if(cookie == null){
        resp.sendRedirect("/login");
        return;
      }
  
      //쿠키가 존재하는 상황이라면
      log.info("cookie는 존재하는 상황");
      //uuid값
      String uuid = cookie.getValue();
  
      try{
        //DB 확인
        MemberDTO memberDTO = MemberService.INSTANCE.getByUUID(uuid);
  
        log.info("쿠키의 값으로 조회한 사용자 정보: " + memberDTO);
        if(memberDTO == null){
          throw new Exception("Cookie value is not valid");
        }
        //회원 정보를 섹션에 추가
        session.setAttribute("loginInfo", memberDTO);
        chain.doFilter(request,response);
  
      }catch (Exception e){
        e.printStackTrace();
        resp.sendRedirect("/login");
      }
    }
  
    private Cookie findCookie(Cookie[] cookies, String name){
      if(cookies == null || cookies.length ==0 ){
        return null;
      }
  
      Optional<Cookie> result = Arrays.stream(cookies)  //cookies 배열을 스트림으로 변환
              .filter(ck -> ck.getName().equals(name))  //특정 조건을 만족하는 요소만 포함하는 새로운 스트림 생성
              .findFirst();                             //첫 번째 요소를 Optional 객체로 반환
  
      return result.isPresent()?result.get():null;
    }
  }
  ```

> 앞의 코드가 적용된 후에 '/todo/list'를 호출하는 경우를 생각해보면 <br>
> HttpSession내에 loginInfo로 저장된 객체도 없고, remember-me 쿠키에도 아무것도 없다면 '/login'으로 Redirect.<br>
> HttpSession에는 없지만 쿠키가 있는 경우, DB에서 uuid가 존재하고 쿠키가 전송된다면 정상적으로 로그인 처리.

















