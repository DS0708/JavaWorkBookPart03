# 3.3 리스터(Listener)

서블릿 API에는 리스너(Listener)라는 이름이 붙은 특별한 인터페이스들이 존재한다. 리스터 객체들은 Event라는 
특정한 데이터가 발생하면 자동으로 실행되는 특징이 있다. 리스너를 이용하면 어떤 이벤트가 발생했을 때 미리 약속해둔
동작을 수행할 수 있으므로 기존의 코드를 변경하지 않고도 추가적인 기능을 수행할 수 있다. <br>
이번 절에서는 리스너를 살펴보는 이유는 스프링 MVC가 리스너를 통해 동작하기 때문이다.


## 리스너의 개념과 용도
- 프로그램을 작성하다 보면 어떤 작업의 영향으로 다른 작업이 같이 실행되어야 하는 경우가 있다.
- 예를 들자면 현재 서버에 접속한 모든 사용자의 IP를 로그로 남겨야 하는 경우 말이다.
- 가장 무식한 방법은 모든 컨트롤러의 코드를 열어 doGet()/doPost()에 로그를 기록하는 방법이지만 이렇게 하지 않기 위해 우리는 
`옵저버(observer)`패턴을 사용한다.
- 옵저버 패턴이란 특정한 변화를 `구독(subscribe)`하는 객체들을 보관하고 있다가 변화가 `발생(publish)`하면 구독 객체들을
실행하는 방식이다.
- 실생활에서는 '재난 감시 시스템'이 좋은 예가 될 수 있는데, 지진 감지 센서가 데이터를 인지해 이벤트를 발생시키면 이 이벤트는
관제 센터에 통보되고 관제 센터에서는 산하 기관들에게 '지진이 발생했음'을 알려주게 되는데 마지막 산하 기관들이 바로 '이벤트 리스너'라고
하는 존재가 된다.

> 서블릿 API는 여러 Event에 맞는 리스너들을 Interface들로 정의해 두었는데 이를 이용해 다음과 같은 작업을 처리 가능하다.

- 해당 웹 애플리케이션이 시작되거나 종료될 때 특정한 작업을 수행
- HttpSession에 특정한 작업에 대한 감시와 처리
- HttpServletRequest에 특정한 작업에 대한 감시와 처리

## 실습 -> ServletContextListener
- 프로젝트를 개발하다 보면 해당 프로젝트가 실행되자마자 실행되었으면 하는 작업이 있을 수 있는데 ServletContextListener는
이러한 작업을 위해 사용한다.
- 프로젝트 내에 listener라는 패키지를 생성하고 이 패키지 내에 W2AppListener클래스를 생성하며 코드는 다음과 같다.
  ```java
  @WebListener
  @Log4j2
  public class W2AppListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent sce) {
      log.info("-------init------------------------");
      log.info("-------init------------------------");
      log.info("-------init------------------------");
    }
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
      log.info("-------destroy------------------------");
      log.info("-------destroy------------------------");
      log.info("-------destroy------------------------");
    }
  }
  ```
  - ServletContextListener 인터페이스를 구현하도록 한다.
  - @WebListener라는 어노테이션을 추가한다.
  - 클래스 내부에서는 contextInitialized()와 contextDestroyed()를 오버라이드 하며 각각 프로잭트가 실행/종료 시점에
  실행된다.


### ServletContextEvent와 ServletContext
- 위의 코드에서 contextInitialized()와 contextDestroyed()에서는 ServletContextEvent 객체가 파라미터로 전달된다.
- ServletContextEvent를 이용해 현재 애플리케이션이 실행되는 공간인 ServletContext를 접근할 수 있다.
- ServletContext는 쉽게 말하자면 현재 웹 애플리케이션 내 모든 자원들을 같이 사용하는 공간이므로 이 공간에 무언가를 저장
하면 모든 컨트롤러나 JSP 등에서 이를 활용할 수 있게 된다.
- ServletContext에는 setAttribute()를 이용해 원하는 이름으로 객체를 보관할 수 있으며 여기서는 'appName'이라는 이름으로
'W2'라는 value를 지정해보려고 한다.
- 이렇게 ServletContext를 이용해 저장된 객체는 서블릿 JSP/EL에 공유해서 사용할 수 있으며, 특히 EL의 경우 ${appName}과 같이
단순한 이름만을 이용해도 이를 활용할 수 있다.
- 다음은 수정된 코드다.
  ```java
  @Override
      public void contextInitialized(ServletContextEvent sce) {
        log.info("-------init------------------------");
        log.info("-------init------------------------");
        log.info("-------init------------------------");
    
        ServletContext servletContext = sce.getServletContext();
        servletContext.setAttribute("appName","W2");
      }
  ```
- HttpServletRequest에서도 getServletContext()를 이용하여 ServletContext에 접근 가능하다.
- 이를 TodoListController에 적용한 코드이다.
  ```java
  @WebServlet(name="TodoListController", value = "/todo/list")
  @Log4j2
  public class TodoListController extends HttpServlet {
    private TodoService todoService = TodoService.INSTANCE;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
      log.info("todo list....................");
  
      ServletContext servletContext = req.getServletContext();
      log.info("appName: " + servletContext.getAttribute("appName"));
  
      try{
        List<TodoDTO> dtoList = todoService.listAll();
        req.setAttribute("dtoList",dtoList);
        req.getRequestDispatcher("/WEB-INF/todo/list.jsp")
                .forward(req,resp);
      }catch (Exception e){
        log.error(e.getMessage());
        throw new ServletException("list error");
      }
    }
  }
  ```
- 그리고 마지막으로 list.jsp에 EL로 적용해보겠다.
  ```html
  <h1>Todo List</h1>
  
  <h2>${appName}</h2>
  <h2>${loginInfo}</h2>
  <h2>${loginInfo.mname}</h2>
  ```


### ServletContextListener와 스프링 프레임워크
- ServletContextListener와 ServletContext를 이용하면 프로젝트가 실행될 때 필요한 객체들을 준비하는 작업을 처리할
수 있다.
- 예를 들어 커넥션 풀을 초기화하거나 TodoService와 같은 객체들을 미리 생성해서 보관할 수 있다.
- 예제에서는 같은 객체를 사용하기 위해 enum으로 객체를 하나만 생성해서 사용했던 모든 예제를 처리할 수 있다.
- ServletContextListener를 설명하는 진짜 이유는 스프링 프레임워크와 관련이 있기 때문이다.
- 스프링 프레임워크를 웹 프로젝트에서 미리 로딩하는 작업을 처리할 때 ServletContextListener를 이용한다.


## 실습 -> 세션 관련 리스너
- 서블릿의 리스너 중에는 HttpSession 관련 작업을 감시하는 리스너들도 등록 가능하다.
- HttpSessionListener나 HttpSessionAttributeListener 등이 바로 그러한 예이며 이를 이용해 HttpSession이
생성되거나 setAttribute() 등의 작업이 이루어질 때 이를 감지할 수 있다.
- listener 패키지에 LoginListener클래스를 추가하고 코드는 다음과 같다.
  ```java
  @WebListener
  @Log4j2
  public class LoginListener implements HttpSessionAttributeListener {
    @Override
    public void attributeAdded(HttpSessionBindingEvent event) {
      String name = event.getName();
      Object obj = event.getValue();
  
      if(name.equals("loginInfo")){
        log.info("A user logined........");
        log.info(obj);
      }
    }
  }
  ```
  - LoginListener는 HttpSessionAttributeListener 인터페이스를 구현했는 데, 이 인터페이스는 attributeAdded(),
  attributeRemoved(), attributeReplaced()를 이용해서 HttpSession에 setAttribute()/removeAttribute() 등의
  작업을 감지할 수 있다.
  - 위의 코드가 적용되면 새로운 로그인이 발생하면 로그에는 다음과 같은 메시지가 출력된다.
  ```
  INFO  org.zerock.w2.listener.LoginListener - A user logined........
  INFO  org.zerock.w2.listener.LoginListener - MemberDTO(mid=user00, mpw=1111, mname=사용자0, uuid=null)
  ```


